/*
 * generated by Xtext 2.24.0
 */
package kcl.mmdd.course.languages.lobster.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import kcl.mmdd.course.languages.lobster.lobsterLanguages.LobsterProgram
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CreateDatabaseStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CreateTableStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.Statement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.InsertStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.DeleteDataStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.MoreConditionStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.DeleteTableStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CreateTableColumn
import kcl.mmdd.course.languages.lobster.lobsterLanguages.UpdateStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.SelectStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.ConditionStatement
import kcl.mmdd.course.languages.lobster.lobsterLanguages.PrimaryExpression
import kcl.mmdd.course.languages.lobster.lobsterLanguages.IntLiteral
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CharLiteral
import kcl.mmdd.course.languages.lobster.lobsterLanguages.VariableReference
import kcl.mmdd.course.languages.lobster.lobsterLanguages.DataType
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CaculateCondition
import kcl.mmdd.course.languages.lobster.lobsterLanguages.Order
import kcl.mmdd.course.languages.lobster.lobsterLanguages.MoreCondition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LobsterLanguagesGenerator extends AbstractGenerator {

override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val model = resource.contents.head as LobsterProgram
		fsa.generateFile(deriveTargetFileNameFor(model, resource), model.generate)
		
		val sqlName = resource.deriveName
		fsa.generateFile(sqlName + '.sql', model.doGenerateSql(sqlName) )
		
	}
	
	
	def deriveName(Resource resource){
		val origFilename = resource.URI.lastSegment
		origFilename.substring(0,origFilename.indexOf('.')).toFirstUpper + 'Lobster'
	}
	
	
	def deriveTargetFileNameFor(LobsterProgram program, Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}
	def generate(LobsterProgram program)'''
	    Program status:
	      Generate success
	'''	
	
	def doGenerateSql(LobsterProgram program, String sqlName)'''
	    «program.statements.map[generateSqlStatement].join('\n')»
	'''
	
	dispatch def String generateSqlStatement(Statement stmt)''''''
	dispatch def String generateSqlStatement(CreateDatabaseStatement stmt)'''CREATE DATABASE «stmt.dbname.generateExpression»;'''
	
	dispatch def String generateSqlStatement(CreateTableStatement stmt)'''
	          use «stmt.dbname.generateExpression»; 
	          CREATE TABLE «stmt.tbname.generateExpression»(
	          «FOR index: (0..stmt.columns.size-1)»«stmt.columns.get(index).generateSqlStatement»«IF index < stmt.columns.size - 1»,«ENDIF»
	          «ENDFOR»);
	          '''
	dispatch def String generateSqlStatement(InsertStatement stmt)'''
	          INSERT INTO «stmt.tbname.generateExpression» («FOR index: (0..stmt.column.size-1)»«stmt.column.get(index).generateExpression»«IF index < stmt.column.size - 1», «ENDIF»«ENDFOR»)
	          VALUES(«FOR index: (0..stmt.value.size-1)» «stmt.value.get(index).generateExpression»«IF index < stmt.column.size - 1», «ENDIF»«ENDFOR»);
	          '''
	dispatch def String generateSqlStatement(DeleteDataStatement stmt)'''
	          DELETE FROM «stmt.tbname.generateExpression»
	          WHERE «FOR index: (0..stmt.condition.size-1)» «stmt.condition.get(index).generateSqlStatement»«IF index === stmt.condition.size-1»;«ENDIF»«ENDFOR»
	          '''    
	dispatch def String generateSqlStatement(MoreConditionStatement stmt)'''«stmt.column.generateExpression» = «stmt.value.generateExpression» «stmt.morecondition.generateSqlMoreCondition»'''
	dispatch def String generateSqlStatement(DeleteTableStatement stmt)'''DELETE FROM «stmt.tbname.generateExpression»;
	          '''
	dispatch def String generateSqlStatement(CreateTableColumn ct)'''«ct.columnName.generateExpression» «ct.datatype.generateSqlType»«IF ct.size !== null»(«ct.size.generateExpression»)«ENDIF»
	          '''
    dispatch def String generateSqlStatement(UpdateStatement stmt)'''
              UPDATE «stmt.tbname.generateExpression»
              SET «FOR index: (0..stmt.setvalue.size-1)»«stmt.setvalue.get(index).generateSqlStatement»«IF index< stmt.setvalue.size-1»,«ENDIF»
                  «ENDFOR»
              WHERE«FOR index: (0..stmt.condition.size-1)» «stmt.condition.get(index).generateSqlStatement»«IF index < stmt.condition.size-1»,«ENDIF» «IF index === stmt.condition.size-1»;«ENDIF»
                   «ENDFOR»
                   '''
    dispatch def String generateSqlStatement(SelectStatement stmt)'''
              SELECT «stmt.caculateCondition.generateSqlCaculate»(«stmt.column.generateExpression»)
              FROM «stmt.tbname.generateExpression»
              WHERE «FOR index: (0..stmt.condition.size-1)»«stmt.condition.get(index).generateSqlStatement»«IF index < stmt.condition.size-1»,«ENDIF»«ENDFOR»
              ORDER BY «FOR index: (0..stmt.condition1.size-1)»«stmt.condition1.get(index).generateExpression»«IF index < stmt.condition1.size-1»,«ENDIF»«ENDFOR» «stmt.order.generateSqlOrder»;
              '''
    dispatch def String generateSqlStatement(ConditionStatement cs)'''«cs.column.generateExpression» = «cs.value.generateExpression»'''

	dispatch def String generateExpression(PrimaryExpression exp)''''''
	dispatch def String generateExpression(IntLiteral exp)'''«exp.^val»'''
	dispatch def String generateExpression(CharLiteral exp)'''«exp.^vac»'''
	dispatch def String generateExpression(VariableReference exp)'''«exp.^var.value»'''
	
	def String generateSqlType(DataType dataType){
		if(dataType === DataType.INTEGER){
			return "int"
		}else if(dataType === DataType.CHARACTER){
			"varchar"
		}
	}
	
	def String generateSqlCaculate(CaculateCondition cacu){
		if(cacu === CaculateCondition.MAXIMUM){
			return "MAX"
		}else if(cacu === CaculateCondition.MINIMUM){
			return "MIN"
		}else if(cacu === CaculateCondition.AVERAGE){
			return "AVG"
		}else if(cacu === CaculateCondition.COUNT){
			return "COUNT"
		}else if(cacu === CaculateCondition.SUM){
			return "SUM"
		}
	}
	
	def String generateSqlOrder(Order ord){
		if(ord === Order.ASCENDING){
			return "ASC"
		}else if(ord === Order.DESCENDING){
			return "DESC"
		}
	}
	
	def String generateSqlMoreCondition(MoreCondition moco){
		if(moco === MoreCondition.AND){
			return "and"
		}else if(moco === MoreCondition.OR){
			return "or"
		}else if(moco === MoreCondition.FINISH){
			return " "
		}
	}
}
