/*
 * generated by Xtext 2.24.0
 */
package kcl.mmdd.course.languages.lobster.serializer;

import com.google.inject.Inject;
import java.util.Set;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CharLiteral;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.ConditionStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CreateDatabaseStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CreateTableColumn;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.CreateTableStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.DeleteDataStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.DeleteTableStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.InsertStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.IntLiteral;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.LobsterLanguagesPackage;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.LobsterProgram;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.MoreConditionStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.SelectStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.UpdateStatement;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.VariableCharacter;
import kcl.mmdd.course.languages.lobster.lobsterLanguages.VariableReference;
import kcl.mmdd.course.languages.lobster.services.LobsterLanguagesGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LobsterLanguagesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LobsterLanguagesGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LobsterLanguagesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LobsterLanguagesPackage.CHAR_LITERAL:
				sequence_CharLiteral(context, (CharLiteral) semanticObject); 
				return; 
			case LobsterLanguagesPackage.CONDITION_STATEMENT:
				sequence_ConditionStatement(context, (ConditionStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.CREATE_DATABASE_STATEMENT:
				sequence_CreateDatabaseStatement(context, (CreateDatabaseStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.CREATE_TABLE_COLUMN:
				sequence_CreateTableColumn(context, (CreateTableColumn) semanticObject); 
				return; 
			case LobsterLanguagesPackage.CREATE_TABLE_STATEMENT:
				sequence_CreateTableStatement(context, (CreateTableStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.DELETE_DATA_STATEMENT:
				sequence_DeleteDataStatement(context, (DeleteDataStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.DELETE_TABLE_STATEMENT:
				sequence_DeleteTableStatement(context, (DeleteTableStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.INSERT_STATEMENT:
				sequence_InsertStatement(context, (InsertStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case LobsterLanguagesPackage.LOBSTER_PROGRAM:
				sequence_LobsterProgram(context, (LobsterProgram) semanticObject); 
				return; 
			case LobsterLanguagesPackage.MORE_CONDITION_STATEMENT:
				sequence_MoreConditionStatement(context, (MoreConditionStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.SELECT_STATEMENT:
				sequence_SelectStatement(context, (SelectStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.UPDATE_STATEMENT:
				sequence_UpdateStatement(context, (UpdateStatement) semanticObject); 
				return; 
			case LobsterLanguagesPackage.VARIABLE_CHARACTER:
				sequence_VariableCharacter(context, (VariableCharacter) semanticObject); 
				return; 
			case LobsterLanguagesPackage.VARIABLE_REFERENCE:
				sequence_VariableReference(context, (VariableReference) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns CharLiteral
	 *     CharLiteral returns CharLiteral
	 *
	 * Constraint:
	 *     vac=STRING
	 */
	protected void sequence_CharLiteral(ISerializationContext context, CharLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.CHAR_LITERAL__VAC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.CHAR_LITERAL__VAC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharLiteralAccess().getVacSTRINGTerminalRuleCall_0(), semanticObject.getVac());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConditionStatement returns ConditionStatement
	 *
	 * Constraint:
	 *     (column=PrimaryExpression value=PrimaryExpression)
	 */
	protected void sequence_ConditionStatement(ISerializationContext context, ConditionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.CONDITION_STATEMENT__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.CONDITION_STATEMENT__COLUMN));
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.CONDITION_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.CONDITION_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionStatementAccess().getColumnPrimaryExpressionParserRuleCall_1_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getConditionStatementAccess().getValuePrimaryExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CreateDatabaseStatement
	 *     CreateDatabaseStatement returns CreateDatabaseStatement
	 *
	 * Constraint:
	 *     dbname=PrimaryExpression
	 */
	protected void sequence_CreateDatabaseStatement(ISerializationContext context, CreateDatabaseStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.CREATE_DATABASE_STATEMENT__DBNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.CREATE_DATABASE_STATEMENT__DBNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreateDatabaseStatementAccess().getDbnamePrimaryExpressionParserRuleCall_4_0(), semanticObject.getDbname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CreateTableColumn returns CreateTableColumn
	 *
	 * Constraint:
	 *     (columnName=PrimaryExpression datatype=DataType size=IntLiteral?)
	 */
	protected void sequence_CreateTableColumn(ISerializationContext context, CreateTableColumn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns CreateTableStatement
	 *     CreateTableStatement returns CreateTableStatement
	 *
	 * Constraint:
	 *     (tbname=PrimaryExpression dbname=PrimaryExpression columns+=CreateTableColumn*)
	 */
	protected void sequence_CreateTableStatement(ISerializationContext context, CreateTableStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteDataStatement
	 *     DeleteDataStatement returns DeleteDataStatement
	 *
	 * Constraint:
	 *     (condition+=MoreConditionStatement* tbname=PrimaryExpression)
	 */
	protected void sequence_DeleteDataStatement(ISerializationContext context, DeleteDataStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteTableStatement
	 *     DeleteTableStatement returns DeleteTableStatement
	 *
	 * Constraint:
	 *     tbname=PrimaryExpression
	 */
	protected void sequence_DeleteTableStatement(ISerializationContext context, DeleteTableStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.DELETE_TABLE_STATEMENT__TBNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.DELETE_TABLE_STATEMENT__TBNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteTableStatementAccess().getTbnamePrimaryExpressionParserRuleCall_1_0(), semanticObject.getTbname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns InsertStatement
	 *     InsertStatement returns InsertStatement
	 *
	 * Constraint:
	 *     ((column+=PrimaryExpression value+=PrimaryExpression)* tbname=PrimaryExpression)
	 */
	protected void sequence_InsertStatement(ISerializationContext context, InsertStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     val=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.INT_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.INT_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValINTTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LobsterProgram returns LobsterProgram
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_LobsterProgram(ISerializationContext context, LobsterProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MoreConditionStatement returns MoreConditionStatement
	 *
	 * Constraint:
	 *     (column=PrimaryExpression value=PrimaryExpression morecondition=MoreCondition)
	 */
	protected void sequence_MoreConditionStatement(ISerializationContext context, MoreConditionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.MORE_CONDITION_STATEMENT__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.MORE_CONDITION_STATEMENT__COLUMN));
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.MORE_CONDITION_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.MORE_CONDITION_STATEMENT__VALUE));
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.MORE_CONDITION_STATEMENT__MORECONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.MORE_CONDITION_STATEMENT__MORECONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoreConditionStatementAccess().getColumnPrimaryExpressionParserRuleCall_1_0(), semanticObject.getColumn());
		feeder.accept(grammarAccess.getMoreConditionStatementAccess().getValuePrimaryExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getMoreConditionStatementAccess().getMoreconditionMoreConditionEnumRuleCall_4_0(), semanticObject.getMorecondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SelectStatement
	 *     SelectStatement returns SelectStatement
	 *
	 * Constraint:
	 *     (
	 *         caculateCondition=CaculateCondition? 
	 *         column=PrimaryExpression 
	 *         condition+=ConditionStatement* 
	 *         tbname=PrimaryExpression 
	 *         condition1+=PrimaryExpression* 
	 *         order=Order?
	 *     )
	 */
	protected void sequence_SelectStatement(ISerializationContext context, SelectStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UpdateStatement
	 *     UpdateStatement returns UpdateStatement
	 *
	 * Constraint:
	 *     (tbname=PrimaryExpression setvalue+=ConditionStatement* condition+=ConditionStatement*)
	 */
	protected void sequence_UpdateStatement(ISerializationContext context, UpdateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableCharacter
	 *     VariableCharacter returns VariableCharacter
	 *
	 * Constraint:
	 *     (name=ID value=INT)
	 */
	protected void sequence_VariableCharacter(ISerializationContext context, VariableCharacter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.VARIABLE_CHARACTER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.VARIABLE_CHARACTER__NAME));
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.VARIABLE_CHARACTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.VARIABLE_CHARACTER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableCharacterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableCharacterAccess().getValueINTTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns VariableReference
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     var=[VariableCharacter|ID]
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LobsterLanguagesPackage.Literals.VARIABLE_REFERENCE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LobsterLanguagesPackage.Literals.VARIABLE_REFERENCE__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReferenceAccess().getVarVariableCharacterIDTerminalRuleCall_0_1(), semanticObject.eGet(LobsterLanguagesPackage.Literals.VARIABLE_REFERENCE__VAR, false));
		feeder.finish();
	}
	
	
}
